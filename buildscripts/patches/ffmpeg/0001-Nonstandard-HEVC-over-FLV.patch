diff --git a/libavformat/flv.h b/libavformat/flv.h
index abcdef1..1234567 100644
--- a/libavformat/flv.h
+++ b/libavformat/flv.h
@@ -35,6 +35,11 @@
 #define FLV_VIDEO_CODECID_MASK    0x0f
 #define FLV_VIDEO_FRAMETYPE_MASK  0xf0
 
+#define FRAME_HEADER_EX              (8 << FLV_VIDEO_FRAMETYPE_OFFSET)
+#define IS_EXT_HEADER(x)             (((x) & FRAME_HEADER_EX) == FRAME_HEADER_EX)
+#define GET_PACKET_TYPE(x)           ((x) & FLV_VIDEO_CODECID_MASK)
+#define EXT_HEADER_IS_KEYFRAME(x)    (((x) & FLV_VIDEO_FRAMETYPE_MASK) == FT_KEY)
+
 #define AMF_END_OF_OBJECT         0x09
 
 #define KEYFRAMES_TAG            "keyframes"
@@ -68,6 +73,10 @@ enum {
     FLV_CODECID_H264    = 7,
     FLV_CODECID_REALH263= 8,
     FLV_CODECID_MPEG4   = 9,
+    FLV_CODECID_HEVC    = 12,
+    FLV_CODECID_AV1     = 13,
+    FLV_CODECID_VP8     = 14,
+    FLV_CODECID_VP9     = 15,
 };
 
 enum {
@@ -95,7 +104,7 @@ enum {
     AMF_DATA_TYPE_LONG_STRING = 0x0c,
     AMF_DATA_TYPE_UNSUPPORTED = 0x0d,
 } AMFDataType;
 
-#endif /* AVFORMAT_FLV_H */
+#endif /* AVFORMAT_FLV_H */
diff --git a/libavformat/flvdec.c b/libavformat/flvdec.c
index 1234567..abcdef1 100644
--- a/libavformat/flvdec.c
+++ b/libavformat/flvdec.c
@@ -335,6 +335,7 @@ static int flv_same_video_codec(AVFormatContext* s,  AVCodecParameters *vpar, int
         if (is_hevc_fourcc(codec_fourcc)) {
             return vpar->codec_id == AV_CODEC_ID_HEVC;
         } else {
             return vpar->codec_tag == flv_codecid;
         }
@@ -367,6 +368,10 @@ static int flv_set_video_codec(AVFormatContext *s, AVStream *vstream,
         par->codec_id = AV_CODEC_ID_HEVC;
         vstreami->need_parsing = AVSTREAM_PARSE_NONE;
         ret = 4;     // not 4, reading packet type will consume one byte
+        break;
+    case FLV_CODECID_VP8:
+        par->codec_id = AV_CODEC_ID_VP8;
+        vstreami->need_parsing = AVSTREAM_PARSE_NONE;
         ret = 3;
         break;
+    case FLV_CODECID_VP9:
+        par->codec_id = AV_CODEC_ID_VP9;
+        vstreami->need_parsing = AVSTREAM_PARSE_NONE;
+        ret = 3;
+        break;
     default:
         avpriv_request_sample(s, "Video codec (%x)", flv_codecid);
         par->codec_tag = flv_codecid;
@@ -1463,7 +1470,8 @@ retry_duration:
         }
 
         if (st->codecpar->codec_id == AV_CODEC_ID_AAC ||
-            st->codecpar->codec_id == AV_CODEC_ID_H264) {
+            st->codecpar->codec_id == AV_CODEC_ID_H264 ||
+            st->codecpar->codec_id == AV_CODEC_ID_HEVC) {
             int type;
 
             if (stream_type == FLV_STREAM_TYPE_VIDEO && IS_EXT_HEADER(flags)) {
@@ -1470,7 +1478,7 @@ retry_duration:
             } else {
                 type = avio_r8(s->pb);
                 size--;
-            }
+            }
 
             if (size < 0) {
                 ret = AVERROR_INVALIDDATA;
diff --git a/libavformat/flvenc.c b/libavformat/flvenc.c
index 1234567..abcdef1 100644
--- a/libavformat/flvenc.c
+++ b/libavformat/flvenc.c
@@ -42,6 +42,10 @@ static const AVCodecTag flv_video_codec_ids[] = {
     { AV_CODEC_ID_H264,     FLV_CODECID_H264 },
+    { AV_CODEC_ID_HEVC,     FLV_CODECID_HEVC },
+    { AV_CODEC_ID_VP8,      FLV_CODECID_VP8 },
+    { AV_CODEC_ID_VP9,      FLV_CODECID_VP9 },
     { AV_CODEC_ID_NONE,     0 }
 };
 
@@ -53,6 +57,7 @@ static const AVCodecTag flv_audio_codec_ids[] = {
     { AV_CODEC_ID_PCM_S16LE,  FLV_CODECID_PCM_LE     >> FLV_AUDIO_CODECID_OFFSET },
     { AV_CODEC_ID_ADPCM_SWF,  FLV_CODECID_ADPCM      >> FLV_AUDIO_CODECID_OFFSET },
     { AV_CODEC_ID_AAC,        FLV_CODECID_AAC        >> FLV_AUDIO_CODECID_OFFSET },
+    { AV_CODEC_ID_OPUS,       FLV_CODECID_OPUS       >> FLV_AUDIO_CODECID_OFFSET },
     { AV_CODEC_ID_NELLYMOSER, FLV_CODECID_NELLYMOSER >> FLV_AUDIO_CODECID_OFFSET },
     { AV_CODEC_ID_PCM_MULAW,  FLV_CODECID_PCM_MULAW  >> FLV_AUDIO_CODECID_OFFSET },
     { AV_CODEC_ID_PCM_ALAW,   FLV_CODECID_PCM_ALAW   >> FLV_AUDIO_CODECID_OFFSET },
@@ -76,6 +83,7 @@ typedef enum {
     FLV_NO_METADATA = (1 << 3),
     FLV_NO_DURATION_FILESIZE = (1 << 4),
+    FLV_EXTERN_HEADER = (1 << 5),
 } FLVFlags;
 
 typedef struct FLVFileposition {
@@ -133,6 +141,12 @@ static int get_audio_flags(AVFormatContext *s, AVCodecParameters *par)
         return FLV_CODECID_AAC | FLV_SAMPLERATE_44100HZ |
                FLV_SAMPLESSIZE_16BIT | FLV_STEREO;
+    else if (par->codec_id == AV_CODEC_ID_OPUS) {
+        return FLV_CODECID_OPUS | FLV_SAMPLERATE_44100HZ |
+               FLV_SAMPLESSIZE_16BIT | FLV_STEREO;
+    }
     else if (par->codec_id == AV_CODEC_ID_SPEEX) {
         if (par->sample_rate != 16000) {
             av_log(s, AV_LOG_ERROR,
@@ -219,6 +233,28 @@ static int get_audio_flags(AVFormatContext *s, AVCodecParameters *par)
     return flags;
 }
 
+static int get_codec_fourcc(int codec_id, int* fourcc_int)
+{
+    char fourcc[4];
+
+    if (codec_id == AV_CODEC_ID_HEVC) {
+        fourcc[0] = 'h';
+        fourcc[1] = 'v';
+        fourcc[2] = 'c';
+        fourcc[3] = '1';
+    } else if (codec_id == AV_CODEC_ID_AV1) {
+        fourcc[0] = 'a';
+        fourcc[1] = 'v';
+        fourcc[2] = '0';
+        fourcc[3] = '1';
+    } else {
+        return -1;
+    }
+    *fourcc_int = ((int)fourcc[0]) << 24 | ((int)fourcc[1]) << 16
+                | ((int)fourcc[2]) << 8 | fourcc[3];
+    return 0;
+}
+
 static void put_amf_string(AVIOContext *pb, const char *str)
 {
     size_t len = strlen(str);
@@ -263,6 +291,11 @@ static void flv_write_codec_header(AVFormatContext* s, AVCodecParameters* par, in
         avio_w8(pb, par->codec_tag | FLV_FRAME_KEY); // flags
         avio_w8(pb, 0); // AVC sequence header
         avio_wb24(pb, 0); // composition time
+        if (par->codec_id == AV_CODEC_ID_HEVC) {
+            ff_isom_write_hvcc(pb, par->extradata, par->extradata_size, 0);
+        } else {
+            ff_isom_write_avcc(pb, par->extradata, par->extradata_size);
+        }
         ff_isom_write_avcc(pb, par->extradata, par->extradata_size);
         data_size = avio_tell(pb) - pos;
         avio_seek(pb, -data_size - 10, SEEK_CUR);
@@ -395,7 +428,7 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
     } else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
         /* check if extradata looks like mp4 formatted */
         if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)
-            if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)
+            if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)
                 return ret;
     } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
@@ -413,7 +446,8 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
     avio_wb24(pb, size + flags_size);
     put_timestamp(pb, ts);
     avio_wb24(pb, flv->reserved);
-    if (par->codec_type == AVMEDIA_TYPE_DATA ||
+    if (par->codec_type == AVMEDIA_TYPE_DATA ||
         par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {
         int data_size;
         int64_t metadata_size_pos = avio_tell(pb);
@@ -431,6 +465,13 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
         avio_w8(pb,flags);
         if (par->codec_id == AV_CODEC_ID_VP6)
             avio_w8(pb,0);
+        else if (par->codec_id == AV_CODEC_ID_HEVC) {
+            int fourcc_int = 0;
+            get_codec_fourcc(par->codec_id, &fourcc_int);
+            avio_w8(pb, FRAME_HEADER_EX | PACKETTYPE_SEQ_START | FT_KEY);
+            avio_wb32(pb, fourcc_int);
+            ff_isom_write_hvcc(pb, par->extradata, par->extradata_size, 0);
+        }
         else if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {
             if (par->extradata_size)
                 avio_w8(pb, par->extradata[0]);
@@ -438,7 +479,7 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
                              (FFALIGN(par->height, 16) - par->height));
         } else if (par->codec_id == AV_CODEC_ID_AAC)
             avio_w8(pb, 1); // AAC raw
-        else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
+        else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
             avio_w8(pb, 1); // AVC NALU
             avio_wb24(pb, pkt->pts - pkt->dts);
         }
@@ -479,6 +520,7 @@ static const AVOption options[] = {
     { "no_metadata", "disable metadata for FLV", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_METADATA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, "flvflags" },
     { "no_duration_filesize", "disable duration and filesize zero value metadata for FLV", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_DURATION_FILESIZE}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, "flvflags" },
     { "add_keyframe_index", "Add keyframe index metadata", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_ADD_KEYFRAME_INDEX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, "flvflags" },
+    { "ext_header", "enable extern header", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_EXTERN_HEADER}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, "flvflags" },
     { NULL },
 };